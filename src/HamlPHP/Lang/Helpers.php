<?php

/**
 * Returns a double or single quoted string. whatever works without changing the content of the string.
 * Example:
 * @code
 *   quote("McDonald's")            # -> "\"McDonad's\""
 *   quote("You \"win\", looser")     # -> "'You \"win\", looser'" 
 * @endcode
 * 
 * If it can't be done. It will return false.
 * 
 * @param $str
 * @return mixed The quoted string or false
 */
function quote($str)
{
	if(strpos($str, '"') === false)
		return "\"$str\"";
		
	if(strpos($str, "'") === false)
		return "'$str'";
	
	return false;
}

/**
 * Prints a list of attributes specified by an array of (att_name => att_value)
 * 
 * @param array $atts
 * @param bool $echo [optional] Wheter to echo the result or not (default: true)
 * 
 * @return string The list of attributes
 */
function atts($atts, $echo=true)
{
	$str = '';
	$flatten = array();
	
	foreach ($atts as $name => $value)
	{
		if((string)$name != 'id' && (string)$name != 'class' && is_array($value))
		{
			foreach($value as $k => $v)
			{
				// TODO: if we found an Id or a Class attribute here. What should we do? For now, it will replace the original ones instead of append
				$flatten[$k] = $v;	
			}
			unset($atts[$name]);
		}
	}
	
	$atts = array_merge($atts, $flatten);
	
	foreach ($atts as $name => $value)
	{
		if($value === false)
			continue;
		
		if($value === true)
		{
			$str .= " $name=\"$name\"";
		}
		else
		{
			if('id' == (string)$name && is_array($value))
			{
				$str .= ' id="'.join('_', $value);
			}
			elseif ('class' == (string)$name && is_array($value))
				$str .= ' class="'.join(' ', $value);
			else
				$str .= " $name=".quote($value);
		}
	}
	
	if($echo)
		echo $str;
	
	return $str;
}

/**
 * Returns an id generated by joining the class of $obj and the id of $obj, joined by a underscore (_), and prefixing it with $prefix.
 * To get the class, this method will call the class_for() helper.
 * To get the id, this method first check if the \c $id variable is set, if not, it checks for a \c getId()
 * method. If none of them is found, it will use an internal, class specific, object counter.
 * 
 * @param object $obj
 * @param string $prefix [Optional]
 */
function id_for($obj, $prefix = '')
{
	static $counter = array();
	
	if(!empty($prefix))
		$prefix .= '_';

	$klass = class_for($obj).'_';
	
	if(isset($obj->id))
		return $prefix.$klass.$obj->id;
		
	if(method_exists($obj, 'getId'))
		return $prefix.$klass.$obj->getId();
	
	if(!isset($counter[$klass]))
		$counter[$klass] = 0;
	
	$counter[$klass]++;
	
	return $prefix.$klass.$counter[$klass];
}

/**
 * Returns the class name of an object to be used in the class attribute.
 * This behaviour can be overloaded by implement a haml_obj_ref (or hamlObjRef) method.
 * Which MUST return a string. If such method isn't present, it will use php's get_class() function.
 * If prefix is not empty, both, the object's class and the prefix, will be returned separated by one space.
 * 
 * @param object $obj
 * @param string $prefix [Optional]
 */
function class_for($obj, $prefix = '')
{
	if(!empty($prefix))
		$prefix .= ' ';
		
	if(method_exists($obj, 'haml_obj_ref'))
		return $prefix.$obj->haml_obj_ref();
	
	if(method_exists($obj, 'hamlObjRef'))
		return $prefix.$obj->hamlObjRef();
	
	return $prefix.get_class($obj);
}